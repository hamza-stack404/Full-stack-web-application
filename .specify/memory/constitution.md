<!--
Sync Impact Report:
- Version Change: 1.0.0 → 1.1.0
- Bump Rationale: MINOR - Added Phase III sections (AI Chatbot Extension) without breaking Phase II principles
- Modified Principles: None (Phase II principles preserved)
- Added Sections: Phase III: AI Chatbot Extension (AI Architecture Principles, Tech Stack Additions, MCP Tool Standards, AI Agent Behavior, Phase III Non-Negotiables)
- Removed Sections: None
- Templates Requiring Updates:
  ✅ .specify/templates/plan-template.md - Updated to include Phase III constitution checks
  ✅ .specify/templates/spec-template.md - Reviewed, no changes needed (Phase III is additive)
  ✅ .specify/templates/tasks-template.md - Reviewed, no changes needed (Phase III is additive)
  ⚠ .specify/templates/commands/*.md - May need review for MCP tool integration guidance
- Follow-up TODOs: None
- Date: 2026-01-13
-->

# Todo Application Full-Stack Constitution

## Core Principles

### I. Spec-Driven Only
No code shall be written manually. Every line of code must be generated by an AI agent based on a validated task from the specification system. This ensures traceability, consistency, and adherence to the defined architecture.

**Rationale**: Manual code changes bypass the specification process, leading to drift between documentation and implementation. AI-generated code from validated tasks maintains a single source of truth.

### II. Agentic Dev Stack
Follow the strict lifecycle: Specify → Plan → Tasks → Implement. Each phase must be completed and validated before proceeding to the next.

**Rationale**: This structured approach ensures requirements are fully understood, architecturally sound, and broken into testable units before implementation begins.

### III. User Isolation (NON-NEGOTIABLE)
Security is a primary constraint. Every data operation MUST be filtered by the authenticated user's ID. A user shall never be able to access or modify another user's data.

**Rationale**: Data isolation is a fundamental security requirement. Failure to enforce user-level filtering can lead to unauthorized data access and privacy violations.

### IV. Stateless Architecture
The backend shall remain stateless, relying on the database and JWT for context. No session state shall be stored in memory on the server.

**Rationale**: Stateless architecture enables horizontal scaling, simplifies deployment, and eliminates session synchronization issues in distributed systems.

### V. Test-First Development
Tests must be written and approved before implementation. Follow the Red-Green-Refactor cycle: write failing tests, implement to pass, then refactor.

**Rationale**: Test-first development ensures code meets requirements, provides regression protection, and serves as executable documentation.

### VI. API Standards
All API endpoints must follow REST conventions, return JSON responses, use proper HTTP status codes, and validate all inputs using Pydantic models.

**Rationale**: Consistent API design improves developer experience, reduces errors, and enables automatic documentation generation.

## Phase II: Full-Stack Web Application

### Technology Stack Constraints
- **Frontend**: Next.js 16+ (App Router), TypeScript, Tailwind CSS
- **Backend**: Python 3.13+ with FastAPI
- **ORM**: SQLModel for all database interactions
- **Database**: Neon Serverless PostgreSQL
- **Authentication**: JWT-based authentication
- **Environment**: WSL 2 (Ubuntu-22.04) for Windows users

### Architectural Standards
- **Monorepo Structure**: The project must be organized as a monorepo with `/frontend`, `/backend`, and `/specs` directories to maintain a single context for the AI agent
- **API Standards**:
  - All routes must be under `/api/`
  - Return JSON responses only
  - Use Pydantic models for all request and response validation
  - Use proper HTTP status codes (e.g., 401 for Unauthorized, 404 for Not Found)
- **Auth Integration**: Both frontend and backend must use a shared secret for JWT signing and verification
- **UI/UX**: Responsive design using Tailwind CSS; no inline styles allowed

### Documentation & Memory
- **CLAUDE.md Hierarchy**: Maintain a root `CLAUDE.md` for project overview and sub-folder guidance files for technology-specific patterns (Frontend/Backend)
- **Traceability**: Every implementation must reference a specific Task ID from the specification system

### Phase II Definition of Done
- Full CRUD functionality implemented for tasks (Add, View, Update, Delete, Toggle Complete)
- Persistent storage in Neon DB
- Functional User Signup/Signin
- Secured API endpoints requiring valid JWT
- Successful deployment of frontend on Vercel and backend on a reachable URL

## Phase III: AI Chatbot Extension

### AI Architecture Principles
- **Stateless Backend**: Server holds NO conversation state in memory
- **MCP-Native**: Task operations exposed as standardized MCP tools
- **AI-Orchestrated**: OpenAI Agents SDK handles tool invocation
- **Conversation Persistence**: All chat history in database

### Phase III Tech Stack Additions
- **AI Framework**: OpenAI Agents SDK
- **MCP Server**: Official MCP Python SDK
- **Chat UI**: OpenAI ChatKit
- **New Models**: Conversation, Message

### MCP Tool Standards
- Every tool receives user_id parameter
- All tools return structured JSON
- Tools reuse existing Phase II task logic
- Stateless tool execution

### AI Agent Behavior
- Conversational and friendly responses
- Always confirm task operations
- Handle errors gracefully
- Use conversation history for context

### Phase III Non-Negotiables
1. ❌ NEVER store conversation state in memory
2. ❌ NEVER skip user_id validation in MCP tools
3. ❌ ALL chat endpoints require JWT authentication
4. ✅ MUST maintain Phase II backward compatibility
5. ✅ MCP tools MUST wrap existing Phase II functions

## Development Workflow

### Specification Process
1. **Specify**: Create feature specification with user stories, acceptance criteria, and success metrics
2. **Plan**: Design architecture, identify dependencies, and document decisions
3. **Tasks**: Break down into testable, atomic implementation tasks
4. **Implement**: Execute tasks in order, validating each before proceeding

### Quality Gates
- All code must pass type checking (TypeScript/Python)
- All tests must pass before merging
- API contracts must be validated against OpenAPI specification
- Security review required for authentication/authorization changes

### Code Review Requirements
- All changes must reference a task ID
- Constitution compliance must be verified
- Test coverage must be maintained or improved
- Breaking changes require explicit justification and migration plan

## Governance

### Amendment Process
Constitution amendments require:
1. Documented rationale for the change
2. Impact analysis on existing code and templates
3. Version bump following semantic versioning (MAJOR.MINOR.PATCH)
4. Update of all dependent templates and documentation

### Versioning Policy
- **MAJOR**: Backward incompatible governance/principle removals or redefinitions
- **MINOR**: New principle/section added or materially expanded guidance
- **PATCH**: Clarifications, wording, typo fixes, non-semantic refinements

### Compliance Review
All PRs and reviews must verify compliance with this constitution. Complexity must be justified. Deviations require explicit approval and documentation.

**Version**: 1.1.0 | **Ratified**: 2026-01-04 | **Last Amended**: 2026-01-13
